  
处理器允许系统内存的任何区域被缓存在L1、L2和L3缓存中。在系统内存的单独页面或区域中，它允许指定缓存的类型（也称为内存类型）。目前为Intel 64和IA-32架构定义的内存类型包括
- **强不可缓存（UC）**：系统内存位置不被缓存。所有读写操作都出现在系统总线上，并且按程序顺序执行，不进行重排序。不进行推测性内存访问、页表遍历或推测性分支目标的预取。这种缓存控制对于内存映射I/O设备很有用。当与普通RAM一起使用时，它会大大降低处理器性能。

> [!注意]
> x87和SIMD指令引用内存的行为是依赖于实现的。在某些实现中，对UC内存的访问可能会发生多次。
> 为了确保可预测的行为，使用通用寄存器的加载和存储来访问可能具有读写副作用的UC内存。
> 对于**具有读副作用的内存映射I/O**，应始终使用强不可缓存内存。
>  > “具有读副作用的内存映射I/O”指的是那些在执行读操作时，会对系统的状态或者数据产生影响的内存映射输入/输出（I/O）操作。在内存映射I/O中，设备的控制寄存器或状态寄存器被映射到主存储器的地址空间中，这样软件就可以通过对这些地址的读写来控制硬件设备。然而，某些设备的设计使得读取它们的状态寄存器可能会改变设备的状态或者清除某些类型的事件或错误状态，这就是所谓的“读副作用”。就比如：
>  >1. **中断状态寄存器**：某些设备使用中断状态寄存器来通知CPU有事件发生。当CPU读取这个寄存器来检测哪个事件发生时，寄存器中的相应位可能会被自动清零。这种读操作不仅返回了状态信息，同时也改变了寄存器的状态，这就产生了读副作用。 
>  > 2. **FIFO（先进先出）缓冲区**：在使用FIFO缓冲区的设备中，如串行端口，读取接收缓冲区实际上会从FIFO中移除数据，改变了缓冲区的内容。这种读取操作的副作用是缓冲区中的数据被消耗。
>  >3. **硬件计数器或定时器**：在读取一个硬件计数器或定时器的值时，某些设备可能会自动重置计数器。这样的读操作改变了设备的状态，因而具有副作用。


- **不可缓存（UC-）**：具有与强不可缓存（UC）内存类型相同的特征，除了这种内存类型可以通过编程MTRRs为WC内存类型来覆盖。这种内存类型从Pentium III处理器家族开始可用，只能通过PAT选择。
-  **写组合（WC）**：系统内存位置不被缓存（如同不可缓存内存）并且处理器的总线一致性协议不强制执行一致性。允许推测性读取(Speculative Reading)。写操作可能会被延迟并在写组合缓冲区（WC缓冲区, Write Combining Buffer）中合并以减少内存访问。如果WC缓冲区部分填充，写操作可能会被延迟到下一个序列化事件发生时，例如SFENCE或MFENCE指令、CPUID或其他序列化指令、对不可缓存内存的读写、中断发生，或执行LOCK指令（包括带有XACQUIRE或XRELEASE前缀的）。此外，执行XEND指令（结束事务区域）会在执行XBEGIN指令（开始事务区域）之前清除缓冲的任何写操作，然后才是事务区域内执行的任何写操作。这种缓存控制适用于视频帧缓冲区，其中写操作的顺序不重要，只要写操作更新内存，以便在图形显示上可见。
-  **写通（WT）**：对系统内存的写入和读取被缓存。读取在缓存命中时来自缓存行；读取未命中导致缓存填充。允许推测性读取。所有写入都写入到缓存行（如果可能）并通过系统内存。**当写入到内存时，无效缓存行永远不会被填充，有效缓存行要么被填充要么被无效化。** 允许写组合。这种缓存控制适用于帧缓冲区或当系统总线上有访问系统内存但不执行内存访问监听的设备时。它强制执行处理器中的缓存与系统内存之间的一致性。

> [!特殊句子详解]
> 1. **“当写入到内存时，无效缓存行永远不会被填充”**：这意味着如果CPU需要写入的数据当前不在缓存中（即，缓存行是无效的），在执行写入操作时，它不会因此将这些数据读入缓存中填充这个缓存行。简而言之，对于不在缓存中的数据，写操作只会影响系统内存，而不会引起缓存行的填充。
> 2. **“有效缓存行要么被填充要么被无效化”**：这部分说明了当写入操作涉及到已经缓存在缓存中的数据（即，缓存行是有效的）时，这个缓存行可能会被更新（填充）以反映新的数据，或者在某些情况下被标记为无效，以指示这部分缓存的数据不再反映系统内存的最新状态。这取决于具体的缓存策略和当前操作的性质。

-  **回写（WB, 最简单的系统内存模型通常采用这个）**：对系统内存的写入和读取被缓存。读取在缓存命中时来自缓存行；读取未命中导致缓存填充。允许推测性读取。写入未命中导致缓存行填充，并且尽可能完全在缓存中执行写入。允许写组合。回写内存类型通过减少许多不必要的对系统内存的写入来减少总线流量。对缓存行的写入不会立即转发到系统内存；相反，它们在缓存中累积。修改后的缓存行稍后写入系统内存，当执行回写操作时。回写操作在需要释放缓存行时触发，例如当在已满的缓存中分配新缓存行时。它们还由用于维护缓存一致性的机制触发。这种缓存控制提供了最佳性能，但它要求所有在系统总线上访问系统内存的设备能够监听内存访问以确保系统内存和缓存一致性。

> [!注意]
> I/O代理可以执行对回写内存的直接内存访问（DMA），并且缓存协议维护缓存一致性。

-  **写保护（WP）**：尽可能从缓存行中读取，读取未命中导致缓存填充。写入传播到系统总线并导致所有处理器上的相应缓存行被无效化。允许推测性读取。

> [!读写情况详解]
> **读写都在系统总线上** ：
> 这意味着：
> - 每次内存访问都会直接影响系统内存，不会在处理器的缓存中留下任何数据的副本。
> - 由于操作直接在系统总线上进行，它们对系统的性能可能有显著影响，尤其是在高频访问时。
> - 这种方式对于内存映射的I/O设备访问非常重要，因为它允许处理器直接与硬件设备交互，确保数据的实时更新。
> 
> **写入传播到系统总线并导致处理器上相应缓存被无效化** ：
> 在多处理器系统中，当一个处理器向共享内存写入数据时，为了维持各个处理器缓存的一致性，系统需要采取一些措施：
> - 写入操作会被传播到系统总线，这个过程中，其他所有处理器的缓存系统会监听到这次写入操作。
> - 监听到写入操作的处理器会检查自己的缓存，如果发现有对应的缓存行，那么这些缓存行会被标记为无效。这确保了下一次访问这部分数据时，处理器会从系统内存中重新读取，保证了数据的一致性。
> - 这种机制是多处理器系统维护缓存一致性的关键，尤其是在处理器频繁读写共享数据时。

| 内存类型及助记符   | 可缓存       | 可回写 | 允许推测性读取 | 内存排序模型                       |
| ---------- | --------- | --- | ------- | ---------------------------- |
| 强不可缓存 (UC) | 否         | 否   | 否       | 强排序                          |
| 不可缓存 (UC-) | 否         | 否   | 否       | 强排序。只能通过PAT选择。可通过MTRRs被WC覆盖。 |
| 写组合 (WC)   | 否         | 否   | 是       | 弱排序。可通过编程MTRRs或通过PAT选择。      |
| 写通 (WT)    | 是         | 否   | 是       | 推测性处理器排序。                    |
| 回写 (WB)    | 是         | 是   | 是       | 推测性处理器排序。                    |
| 写保护 (WP)   | 读取时是；写入时否 | 否   | 是       | 推测性处理器排序。可通过编程MTRRs选择。       |
当软件不能通过从回写缓存中访问数据结构而受益时，可以采用**页面级缓存控制**，以分配适当的有效内存类型。例如，软件可能一次性读取一个大型数据结构，然后在另一个代理重写该结构之前不再访问该结构。这样的大型数据结构应该被标记为不可缓存，否则读取它将会逐出处理器将再次引用的缓存行。