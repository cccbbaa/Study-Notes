FRED(Flexible Return and Event Delivery)是一个特定的 CPU 特性，用于改进和优化中断处理和事件交付机制。主要分为几个部分：
- FRED 事件交付(FRED event delivery): 
	使用 FRED 时，任何通常会触发 IDT 事件交付的事件（如中断或异常）不再依赖传统的 IDT 数据结构来确定处理程序的地址。而是当发生这些事件时，处理器会建立一个新的上下文，这个上下文不需要访问 IDT 等现有的数据结构。新的上下文可能包括新的指令指针、栈指针、状态寄存器等，用于处理事件。
	同时 FRED 会改变,`syscall`和`sysenter`指令的行为，这些指令不再是会让处理器查找 IDT 以跳转到相应的处理程序，而是直接通过 FRED 机制建立新的上下文。
- FRED 返回指令(FRED return instructions)：
	`ERETS`和`ERETU`这两条新指令用于返回事件处理 ERETS (event return to supervisor) 被设计为用来返回到 0 环并且不改变 CPL(current privilege level) 的事件，同时还会恢复先前的栈级别(见下文介绍)以及先前的栈；ERETU (event return to user) 用来返回到 3 环的应用软件。
- 管理 GS 段寄存器(GS segment management)
	在正常 x86 架构中，GS 段寄存器通常用来指向一些 TLS 变量(内核中的线程环境块(PEB)等)。`swapgs`指令用于在用户态和内核态之间切换时交换 `GS` 基址寄存器的值。通常在从用户态进入内核态时调用 `SWAPGS`，以便使用正确的 `GS` 基址指向内核或用户数据。
	在 FRED 架构下，FRED 能在当 CPL 发生转换时自动更新 `GS`基址，使其正确指向新的上下文中的数据结构。同时 FRED 引入了`LKGS`指令，用于更灵活地管理`GS`段

FRED 架构引入了一个新概念，CSL(current stack level) 是处理器在当前上下文跟踪的栈级别。这个级别的取值范围是 `0` 到 `3`，并且只在 CPL等于 `0` 时有效。CSL 能帮助处理器知道执行内核代码时当前应该使用那个栈。
当处理器接收到一个需要 FRED 事件交付的事件（如中断或异常）时，会先确定与该事件关联的栈级别。如果这个事件的栈级别高于当前的 CSL，或之前的 CPL 等于 `3`（即从用户模式进入内核模式），那么处理器会从与该事件栈级别关联的 **FRED RSP MSR**加载新的`RSP`。
如果启用了 监督影子栈(Supervisor Shadow Stacks)，栈级别的管理也会**扩展**到影子栈指针。现有的影子栈架构包含一个令牌管理机制，用于在切换影子栈时确保影子栈的完整性。此机制使用锁定的读取-修改-写入操作，这可能会对最坏情况下的性能产生不利影响。
FRED 过渡(transition)不使用此令牌管理机制，而是通过让 FRED 返回指令检查 FRED SSP MSR 中的值来保护影子栈的完整性。

> [!NOTE] Note
> 在传统的影子栈中，每次切换影子栈会用到令牌，并在影子栈中设置一个`busy bit`。
> 设置`busy bit`过程会涉及到锁定和RMW等复杂的操作。这些操作可能会影响性能，特别是设置`busy bit`后导致的任何`exception`或`vm exit`还会需要额外的处理和恢复步骤。
> 
> FRED 架构在处理事件交付过程中，不需要设置影子栈的`busy bit`，因此会减少相关的复杂操作，并且也不会导致何`exception`或`vm exit`。
> 
> `CPUID.(EAX=07H, ECX=1H):EDX[bit 18]`特定地表示处理器是否支持影子栈的令牌管理机制。在传统影子栈中，操作系统需要在启用监督影子栈之前检查这个位是否被设置。但在 FRED 架构中，不再需要检查这个位。

## 4 枚举、启用和设置 FRED
---
### 4.1 Enumeration
FRED 架构包括两个相关但独立的元素：FRED 过渡和用于管理 GS 段寄存器的 `LKGS` 指令。64 位操作系统可能无需使用 FRED 就能从 `LKGS` 指令中受益，因此这两个元素是独立列举的。

`CPUID.(EAX=7,ECX=1):EAX.FRED[bit 17]`是用来标识处理器是否支持 FRED 过渡，同时也用来标识处理器是否支持 FRED 定义的新体系结构状态（例如，通过新的 MSR 寄存器来管理上下文）。
`CPUID.(EAX=7,ECX=1):EAX.LKGS[bit 18]`用来标识处理器是否支持 `LKGS` 指令。
`CPUID.(EAX=7,ECX=1):EAX.NMI_SRC[bit 20]`用于标识处理器是否支持 `NMI` 源报告功能。

### 4.2 在CR4中启用
通过设置CR4\[32\]（以下简称CR4.FRED）来启用 FRED 过渡。具体来说，设置`CR4.FRED`会启用FRED 事件交付以及 FRED 返回指令，这些指令只能在64位模式下使用（当CS.L = 1时）。

在64位模式之外执行MOV到CR4指令会清除CR4\[63:32\]。因此，软件必须首先进入64位模式，然后才能使用MOV到CR4指令来设置CR4.FRED。该架构确保CR4.FRED为1时，逻辑处理器必须处于IA-32e模式（即IA32_EFER.LMA = 1）：

- 正如前面所述，MOV到CR4指令只能在IA-32e模式下设置CR4.FRED。
- 软件只能通过执行MOV到CR0指令来清除CR0.PG以离开IA-32e模式，而且这只能在兼容模式下并且CPL = 0时完成。（在64位模式下尝试清除CR0.PG会导致故障。）
- 如果CR4.FRED = 1，在CPL = 0的情况下无法进入兼容模式。
- RSM（恢复系统管理模式）和VMX（虚拟机扩展）过渡不能在IA-32e模式之外进入CR4.FRED = 1的状态。

CR4.FRED的值不会影响通过RDMSR和WRMSR指令访问新的MSR，也不会影响新的LKGS指令的操作。

### 4.3 关于设置 FRED 过渡的新MSR寄存器
IA32_FRED_CONFIG (MSR索引1D4H)：
- 该MSR的第1:0位包含当前栈级别（CSL）。这是一个2位的值，由FRED事件交付（见第5节）和FRED返回指令（见第6节）使用和操作。
- 软件可以使用`WRMSR`指令修改CSL，但这不是预期的用法。建议在使用`WRMSR`更新IA32_FRED_CONFIG时，软件应将现有的CSL写入MSR的第1:0位（除非特别需要更改CSL）。
- 第2位保留。
- 第3位指示（如果设置），在FRED事件交付未改变栈时，应将影子栈指针（SSP）减少8。
- 第5:4位保留。
- 第8:6位标识在不改变栈时，FRED事件交付减少常规栈指针（RSP）的量（以64字节缓存行测量）。
- 第10:9位标识用于在 0 环中交付的可屏蔽中断的栈级别。
- 第11位保留。
- 第63:12位包含内存中包含事件处理程序的页面的线性地址的高位。FRED 事件交付将加载RIP以指向该页面上的入口点。
- 如果`WRMSR`的源操作数设置了任何保留位或相对于处理器的最大线性地址宽度不是规范化的，执行`WRMSR`到此MSR会导致通用保护异常（#GP）。

IA32_FRED_RSP0, IA32_FRED_RSP1, IA32_FRED_RSP2和IA32_FRED_RSP3 (MSR索引1CCH–1CFH)：
- 如果FRED事件交付导致从 3 环过渡或更改CSL，它将从与新栈级别对应的FRED RSP MSR加载RSP。
- 如果`WRMSR`的源操作数未64字节对齐（位5:0不是全部为零）或相对于处理器的最大线性地址宽度不是规范化的，执行WRMSR到任何这些MSR会导致通用保护异常（#GP）。

> [!NOTE] Note
> MSR名称中的数字0–3指的是对应的栈级别，而不是特权级别。


IA32_FRED_STKLVLS (MSR索引1D0H)：此MSR被解释为一个32个2位值的数组，每个向量在0–31范围内都有一个2位值。对于 0 环中发生的具有向量v的异常（或始终具有向量v=2的不可屏蔽中断），FRED事件交付确保新栈级别至少为IA32_FRED_STKLVLS\[2v+1:2v\]的值。

IA32_FRED_SSP1, IA32_FRED_SSP2和IA32_FRED_SSP3 (MSR索引1D1H–1D3H)：与现有的MSR IA32_PL0_SSP (MSR索引6A4H) 一起，这些是FRED SSP MSR。本文件中提到的“IA32_FRED_SSP0”指的是IA32_PL0_SSP MSR。
- 如果启用了监督影子栈且FRED事件交付导致从环3过渡或更改CSL，它将从与新栈级别对应的FRED SSP MSR加载SSP。
- IA32_FRED_SSPi（1 ≤ i ≤ 3）中的地址必须是8字节对齐的，因此位2:0是保留的。（由于遗留原因，IA32_PL0_SSP——也称为IA32_FRED_SSP0——允许4字节对齐，因此只有位1:0是保留的。）
- 如果`WRMSR`的源操作数设置了任何保留位或相对于处理器的最大线性地址宽度不是规范化的，执行`WRMSR`到任何这些MSR会导致通用保护异常（#GP）。`XRSTORS`和`WRMSR`的执行如果会加载IA32_PL0_SSP，也会触发相同的行为。

> [!NOTE] Note
> 与FRED RSP MSR类似，MSR名称中的数字0–3指的是对应的栈级别，而不是特权级别。
> 
> 任何CPUID.(EAX=7,ECX=1):EAX.FRED\[bit 17\] 枚举为1的处理器都支持FRED SSP MSR。如果这样的处理器不支持CET（控制流强化技术），FRED过渡将不会使用这些MSR（因为未启用影子栈），但这些MSR仍然可以通过RDMSR和WRMSR访问。
> 
> 每个新MSR的复位状态（RESET state）为零。INIT状态不会改变新MSR的值。

### 4.4 FRED 在现有MSR中的使用
- **IA32_STAR**：
    - **现有用途**：该MSR用于现有的SYSCALL和SYSRET操作。
    - **FRED用途**：FRED事件交付会加载CS和SS选择子，这些选择子值是从IA32_STAR\[47:32\]派生的（参见第5.3节）。ERETU使用IA32_STAR\[63:48\]的值来决定如何加载CS和SS寄存器（参见第6.2.1节）。
    - 预计操作系统将IA32_STAR\[33:32\]设置为0b00，将IA32_STAR\[49:48\]设置为0b11。
- **IA32_KERNEL_GS_BASE**：
    - **现有用途**：SWAPGS指令将该MSR的值与GS段寄存器的基址交换。
    - **FRED用途**：ERETU指令执行同样的交换操作，FRED事件交付中到达环3的事件也执行此操作。
- **IA32_PL0_SSP**：
    - **现有用途**：控制流强化技术（CET）的影子栈功能通常在进入环0时从该MSR加载SSP。
    - **FRED用途**：FRED过渡将此MSR用作IA32_FRED_SSP0（参见第4.3节）

## 5 FRED 事件交付
---
当 FRED 过渡被激活时(CR4.FRED = 1)，IDT 事件交付会被 FRED 事件交付所替代。此外，现有的`SYSCALL`和`SYSENTER`操作也被 FRED 事件交付取代。这些变化不会影响处理器在事件交付之前对异常和中断的处理。例如，任何判断事件是否会导致`VM exit`或被转换为`double fault`的过程都会正常进行。同样，页面错误和调试异常会分别以正常方式更新CR2和DR6。

FRED事件交付的主要功能是在 0 环中建立事件处理程序的新上下文，同时保存旧的上下文以供后续返回使用。新上下文的某些部分具有固定值，而其他部分则依赖于旧的上下文、正在交付的事件的性质以及软件配置。
第5.1节描述了 FRED 事件交付如何确定和建立新上下文。
第5.2节规定了 FRED 事件交付如何在栈上(以及在启用时，在影子栈上)保存旧上下文的元素。
第5.3节接着描述了如何更新额外的状态。
第5.4节则详细介绍了在 FRED 事件交付过程中遇到的故障。

### 5.1 确定和建立新上下文
FRED 事件交付调用的事件处理程序的上下文包括CS和SS段寄存器、指令指针（RIP）、标志寄存器（RFLAGS）、栈指针（RSP）以及GS段的基地址（GS.base）。如果启用了监督影子栈，上下文还包括影子栈指针（SSP）。
FRED 事件交付通过适当地加载这些寄存器来建立此上下文。它根据旧上下文、正在交付的事件的性质以及软件配置来确定要加载到RIP、RSP、GS.base和 SSP 中的值。RFLAGS、CS和SS则加载固定值。

#### 5.1.1 确定新的RIP值

FRED事件交付根据事件发生时的CPL（当前特权级）使用两个入口点。这使事件处理程序能够识别适当的返回指令（ERETU或ERETS）。
具体来说，对于在 3 环发生的事件，FRED 事件交付建立的新`RIP`值为`IA32_FRED_CONFIG & ~FFFH`，而对于在 0 环发生的事件，新`RIP`值为`(IA32_FRED_CONFIG & ~FFFH) + 256`。
如果新的`RIP`值相对于当前的分页模式不是规范化的，FRED 事件交付将导致通用保护故障（#GP）。

> [!NOTE] Note
> 如果此#GP没有导致VM退出，FRED 事件交付的#GP将导致第二个#GP，这将被转换为双重故障（#DF）。如果#DF没有导致VM退出，FRED事件交付的#DF将导致第三个#GP，结果是三重故障，这将导致VM退出或使逻辑处理器进入关机状态。

#### 5.1.2 确定栈级别、RSP 和 SSP 的新值
FRED 过渡支持在 0 环中使用四个不同的栈。逻辑处理器通过一个2位值（称为当前栈级别，CSL）标识当前使用的栈。

FRED 事件交付首先确定事件的栈级别，然后使用该栈级别来判断是否需要更改 CSL。事件的栈级别基于 CPL、事件的性质和类型、事件的向量（对某些事件类型适用）以及由系统软件配置的 MSR 来确定：
- 如果事件发生在 3 环中，不是在事件交付期间遇到的嵌套异常，也不是双重故障（#DF），则事件的栈级别为0。
- 如果事件发生在 0 环中，或者是在事件交付期间遇到的嵌套异常，或者是双重故障（#DF），则应用以下规则：
    - 如果事件是可屏蔽中断，事件的栈级别为 IA32_FRED_CONFIG\[10:9\]。
    - 如果事件是异常或不可屏蔽中断（NMI），事件的栈级别为 IA32_FRED_STKLVLS\[2v+1:2v\]，其中 v 是事件的向量（范围在 0–31 之间）。
 	> [!NOTE] 
	> 异常包括由 INT1、INT3 和 INTO 指令生成的事件，但不包括由 INT n 指令生成的事件（无论 n 的值是多少）。

    - 所有其他事件的栈级别为0。

> [!NOTE] 
> 其他事件是由 INT n 指令（无论 n 的值是多少）、SYSCALL 和 SYSENTER 指令生成的事件。

如果事件发生在 3 环中，新栈级别就是事件的栈级别；否则，新栈级别是 CSL 和事件栈级别中的最大值。（这意味着，除非事件是嵌套异常或双重故障，FRED 事件交付后 3 环中发生的事件的 CSL 始终为0。）

在确定新栈级别后，FRED 事件交付按如下方式确定新的 RSP 值：

- 如果 CPL 或 CSL 发生变化，则新的 RSP 值将是与新栈级别对应的 FRED RSP MSR 的值。
- 否则，新的 RSP 值将是当前 RSP 值减去 IA32_FRED_CONFIG & 1C0H（即该 MSR 的第 8:6 位表示的以64字节为单位的值），然后对齐到64字节边界（通过清除 RSP\[5:0\] 来实现）。

如果启用了监督影子栈，新的 SSP 值按以下方式确定：

- 如果 CPL 或 CSL 发生变化，则新的 SSP 值将是与新栈级别对应的 FRED SSP MSR 的值。如果该新 SSP 值未按8字节对齐，FRED 事件交付将导致通用保护故障（#GP）。

> [!NOTE] 
> IA32_FRED_SSPi（1 ≤ i ≤ 3）中的每个值总是8字节对齐的，因此上述检查仅在从 IA32_PL0_SSP MSR（IA32_FRED_SSP0）加载 SSP 时才有必要。

- 否则，新的 SSP 值将是当前 SSP 值减去 IA32_FRED_CONFIG & 8（设置该 MSR 的第3位表示 SSP 应减去8）。

#### 5.1.3 建立新上下文
在确定新上下文的详细信息后，FRED 事件交付通过加载寄存器来建立该上下文。

对于发生在 3 环中的事件，FRED 事件交付会更新 CS、SS 和 GS 段寄存器以及 IA32_KERNEL_GS_BASE MSR（特定型号寄存器）：

- **CS**：
    - 选择子被设置为 `IA32_STAR[47:32] AND FFFCH`（这将 CS.RPL 强制为 0）。
    - 基地址被设置为 0。限长被设置为 FFFFFH，G 位被设置为 1。
    - 类型被设置为 11（执行/读取已访问代码），S 位被设置为 1。
    - DPL 被设置为 0，P 和 L 位均设置为 1，D 位设置为 0。
    - 无论选择子的值如何，CS 都变为可用。
- **SS**：
    - 选择子被设置为上述 CS 选择子的值加 8（因此，SS.RPL 也为 0）。
    - 基地址被设置为 0。限长被设置为 FFFFFH，G 位被设置为 1。
    - 类型被设置为 3（读取/写入已访问数据），S 位被设置为 1。
    - DPL 被设置为 0，P 和 B 位均设置为 1。
    - 无论选择子的值如何，SS 都变为可用。
- **GS**：FRED 事件交付会交换 GS 基地址和 IA32_KERNEL_GS_BASE MSR 的值。

（上述更新不涉及对 GDT 或 LDT 的任何访问。）

对于发生在环0中的事件，FRED 事件交付不会修改 CS、SS 或 GS。

在更新段寄存器后，FRED 事件交付将按照第 5.1.1 节和第 5.1.2 节中确定的值加载 RIP、RSP 和 CSL。如果启用了监督影子栈，SSP 将按照第 5.1.2 节中确定的值加载。RFLAGS 被加载为值 2（所有位清除，除位置 1 外，它没有功能但始终设置）。

如果在此之后 FRED 事件交付遇到嵌套异常或 VM 退出，处理器将恢复 FRED 事件交付开始之前这些寄存器中的值，然后再交付嵌套异常或 VM 退出。

### 5.2 保存事件和旧上下文的信息
与IDT事件交付类似，FRED事件交付也会在事件处理程序的栈上保存旧上下文的信息。这些信息包括以与IDT事件交付后保存的格式非常相似的方式保存的先前上下文、关于正在交付事件的附加信息，以及将指导后续返回指令的辅助信息。

如果启用了监督影子栈，FRED事件交付还会将信息保存到事件处理程序的影子栈上。

用于在栈上存储信息的内存访问是在监督特权级下执行的。这些内存访问中的任何一个都可能导致嵌套异常。然后，嵌套异常（或可能被转换为的双重故障）将通过FRED事件交付进行处理。

#### 5.2.1 在常规栈上保存信息

FRED事件交付会在新的常规栈上保存64字节的信息，以下是详细说明：

- 被压入栈的首 8 字节（64字节栈帧中的字节63:56）目前未定义，将被设置为零，直到它们被定义。
- 下一个压入栈的8字节（字节55:48）包含事件数据，定义如下：
    - 如果正在交付的事件是页面错误（#PF），事件数据是引发错误的线性地址（这与#PF加载到CR2中的值相同）。(如果#PF发生在安全区模式（enclave mode）指令执行期间（但不包括在安全区模式事件交付期间），事件数据的位11:0将被清除。)
	- 如果正在交付的事件是调试异常（#DB），事件数据标识调试异常的性质：
        - 位 3:0 是B3–B0。当设置时，每个位指示对应的断点条件已满足（即使其对应的启用位在DR7中未设置，这些位也可能被设置）。
        - 位 10:4 目前未定义，将被设置为零，直到它们被定义。
        - 位 11 是BLD。当设置时，该位指示调试异常的原因是获取总线锁（因为IA32_DEBUGCTL\[2\] = 1）。
        - 位 12 目前未定义，将被设置为零，直到它被定义。
        - 位 13 是BD。当设置时，该位指示调试异常的原因是“检测到调试寄存器访问”。
        - 位 14 是BS。当设置时，该位指示调试异常的原因是执行单条指令（因为该指令的执行开始时RFLAGS.TF = 1）。(如果在指令执行开始时，IA32_DEBUGCTL.BTF也为1，则只有当该指令是已采取的分支时才会发生调试异常。)
        - 位 15 目前未定义，将被设置为零，直到它被定义。
        - 位 16 是RTM。当设置时，该位指示在启用了RTM事务区域高级调试的情况下，RTM区域内发生了调试异常（#DB）或断点异常（#BP）。
        - 位 63:17 目前未定义，将被设置为零，直到它们被定义。
        
        事件数据与#DB交付后在DR6中的内容并不完全相同。DR6中的位11和位16的极性与事件数据中相反；此外，#DB交付可能会在DR6中保留一些位，这些位在事件数据中清除，但在DR6中已被设置。
        
    - 如果正在交付的事件是由于扩展功能禁用引起的设备不可用异常（#NM），事件数据指示异常的原因，并与加载到IA32_XFD_ERR MSR中的值相同。如果#NM不是由扩展功能禁用引起的，事件数据为零。
    - 如果正在交付的事件是不可屏蔽中断（NMI），且处理器支持NMI源报告，事件数据的位15:0包含与该NMI关联的NMI源位图；位63:16为零。如果处理器不支持 NMI 源报告，则事件数据为零。
    - 对于任何其他事件，事件数据当前尚未定义，在定义之前将为零。
    - 如果正在交付的事件需要注入到`vm entry`时，事件数据不定。
- 接下来的 40 字节（栈帧中的字节 47:8 ）是返回状态，其格式大体上与IDT事件交付所使用的格式相同。该格式将CS和SS的16位选择子存储在64位字段中。FRED 事件交付在这些选择子的值上增加了额外的信息，并保存在这些字段的上48位中。
  以下内容详细说明了从栈底部（最高地址）到顶部的返回状态格式：
	- **前一个上下文的增强型SS**，格式为64位，如下：
		- 位15:0包含SS选择子。
		- 如果 FRED 事件交付的是硬件异常，且在异常发生时STI指令阻止了中断，则位16被设置为1（执行STI时，如果RFLAGS.IF = 0，则在其执行后的指令边界处阻止中断。）；否则，清除为0。（SYSCALL, SYSENTER, INT1, INT3, or INT n (n为任意值)的事件交付将总会清除这个位，就像这些指令的事件交付中碰到了任何异常一样）
		- 如果FRED事件交付的是SYSCALL、SYSENTER或INT n（无论n的值是多少），则位17被设置为1；否则，清除为 0。
		- 如果正在交付的事件是不可屏蔽中断（NMI），则位18被设置为1；否则，清除为0。
		- 位31:19当前未定义，直到定义之前将被设置为0。
		- 位63:32包含事件信息。这为软件提供了有关事件的附加信息。FRED返回指令会忽略这些位。事件信息的格式如下：
		    - 位39:32包含事件的向量。向量取决于事件的类型：
		        - 对于外部中断，向量由本地APIC提供。
		        - 对于不可屏蔽中断（NMI），向量为2。
		        - 对于硬件异常，向量由异常决定。
		        - 对于软件中断（INT n），向量来自指令的操作码（值n）。
		        - 对于软件异常，向量由指令操作码决定：INT1的向量为1；INT3的向量为3；INTO的向量为4。
		        - 对于SYSCALL和SYSENTER（使用FRED事件交付但不使用IDT事件交付），分别使用向量1和2。
		    - 位47:40当前未定义，直到定义之前将被设置为0。
		    - 位51:48编码事件类型，如下：0 = 外部中断；2 = 不可屏蔽中断；3 = 硬件异常（例如页面错误）；4 = 软件中断（INT n）；5 = 特权软件异常（INT1）；6 = 软件异常（INT3或INTO）；7 = 其他事件（用于SYSCALL和SYSENTER）。其他值未使用。(FRED事件交付使用的事件类型与VMX过渡中定义的事件类型相同。对于SYSCALL或SYSENTER，FRED事件交付报告事件类型 7（其他事件）。对于`VM entry`，该事件类型与向量 0 一起使用，以指示挂起的`MTF VM exit`。这就是为什么FRED事件交付使用向量 1 和 2 分别表示SYSCALL和SYSENTER。)
		    - 位55:52当前未定义，直到定义之前将被设置为0。
		    - 如果事件与安全区执行有关，位56被设置为1。具体地，它在以下任一情况下被设置：
		        - 事件发生在逻辑处理器处于安全区模式时。
		        - 事件由`VM entry`注入（参见第10.5.4节），且VMCS中的客户机不可中断状态字段指示“安全区中断”（字段的位4为1）。
		        - 事件是调试异常，且在`VM entry`后挂起，而此时客户机不可中断状态指示“安全区中断”（参见上文）。
		        - 事件是调试异常，且在执行RSM后挂起，而此时SMRAM指示“安全区中断”。
		        - 事件是在交付上述任何事件时遇到的异常。 否则，清除为0。
		- 如果事件发生时逻辑处理器处于64位模式，位57被设置为1。（值为0表示事件发生在兼容模式下。）
		- 如果事件是FRED事件交付过程中遇到的嵌套异常，位58被设置为1。如果事件是双重故障（#DF），则不设置此位。
		- 位59当前未定义，直到定义之前将被设置为0。
		- 如果事件类型是软件中断（INT n）、特权软件异常（INT1）、软件异常（INT3或INTO），或其他事件（用于SYSCALL或SYSENTER），位63:60包含引发事件的指令长度。（当FRED事件交付用于由VM进入注入的此类事件时，长度的确定方式有所不同。参见第10.5.4节。）对于其他事件类型，这些位将被清除为零。
	- **前一个上下文的RSP**（64位）。
	- **前一个上下文的RFLAGS**（64位）。
		- 当交付与IDT事件交付相同的事件时，RFLAGS字段的第16位（对应于RF位）将保存为1。这些事件包括除了指令断点以外的所有故障，以及任何在指令部分执行后交付的陷阱或中断（例如，在带REP前缀的字符串指令的迭代之间）。交付其他事件时，第16位保存事件发生时RFLAGS.RF的值。
	- **前一个上下文的增强型CS**。FRED返回指令使用该字段的64位。其格式如下：
		- 位15:0包含CS选择子。
		- 位17:16：
		    - 对于在 0 环中发生的事件的交付，这些位报告事件发生时的当前堆栈级别（CSL）。
		    - 对于在 3 环中发生的事件的交付，这些位清除为0。
		- 如果事件发生在 0 环，并且间接分支跟踪器处于WAIT_FOR_ENDBRANCH状态，位18被设置为1。具体地，该位仅在以下所有条件都为真时设置：CPL = 0；CR4.CET = 1；IA32_S_CET.ENDBR_EN = 1；以及IA32_S_CET.TRACKER = 1。 以下条目记录了基于间接分支跟踪操作如何保存位18的影响（提供了关于在环0中发生的特定事件的交付的详细信息）：
		    - 在指令边界发生的事件交付保存位18，并将其设置为该指令边界处跟踪器的状态：
		        - 对于优先于缺失ENDBRANCH `#CP`异常的事件，这个值可以是0或1，具体取决于跟踪器的状态。这些事件包括某些机器检查异常、陷阱类调试异常、不可屏蔽中断、外部中断、指令断点引发的调试异常以及从取指下一个指令引发的故障。它们还可能包括从解码下一个指令引发的故障。
		        - 对于缺失ENDBRANCH `#CP`异常，这个值为1。
		        - 对于优先级低于缺失ENDBRANCH `#CP`异常的解码指令引发的故障，这个值为0。
		    - 交付INT1或INT3时，位18保存为取指INT1或INT3时跟踪器的设置值。（解码这些指令不会清除跟踪器。）
		    - 交付INT n（无论n的值是多少）、SYSCALL或SYSENTER时，位18保存为值0。（解码这些指令会清除跟踪器。）
		    - 在FRED事件交付过程中遇到的异常（包括INT1、INT3、INT n、SYSCALL或SYSENTER的事件交付）保存位18的值，该值本来会被原始事件的交付所保存。
		    - 在执行除INT1或INT3以外的任何指令时遇到的异常交付位18保存为值0。（解码除INT1或INT3以外的任何指令都会清除跟踪器。）
		- 位63:19当前未定义，直到定义之前将被设置为0。
