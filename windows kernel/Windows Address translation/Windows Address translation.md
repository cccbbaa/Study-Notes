# 地址转换

### x86虚拟地址转换

​	最初，受制于当时的CPU硬件，x86 内核只支持不超过4GB 的物理内存。Intel x86Pentium Pro处理器引入了一种名为物理地址扩展(Physical Address Extension，PAE)的内存映射模式。通过搭配适合的芯片组，PAE 模式可以允许在目前的Intel x86处理器上运行的32位操作系统访问最多64GB 物理内存；对于以“遗留模式”运行的x64处理器，最多可访问 1024GB 物理内存(不过为了描述如此多的内存会导致PFN数据库过于庞大目前 Windows 依然将其限制为64GB)。

> PFN（Page Frame Number）数据库是Windows操作系统中用于管理物理内存的一种数据结构 (_MMPFN结构体) 。在Windows中，物理内存被分成大小相等的块，称为页面。PFN数据库是一个包含每个物理页面信息的数组，用于跟踪每个物理页面的状态、位置等属性。
>
> PFN数据库中的每个条目都表示一个物理页面，存储了有关该页面的重要信息。这些信息包括页面的使用情况、页面所属的进程、页面的虚拟地址等。操作系统使用这些信息来执行许多内存管理任务，如页面替换、内存映射、内存共享等。
>
> 以下是`_MMPFN`结构体的一个示例：

```c++
typedef struct _MMPFN {
    union {
        _LIST_ENTRY ListEntry;
        _RTL_BALANCED_NODE TreeNode;
        // anonymous tag for u1
    } u1;
    union {
        _MMPTE *PteAddress;
        uint64_t PteLong;
    } u2;
    _MMPTE OriginalPte;
    _MIPFNBLINK u3;
    uint16_t NodeBlinkLow;
    uint16_t Unused : 4;
    uint16_t Unused2 : 4;
    uint8_t ViewCount;
    uint8_t NodeFlinkLow;
    uint8_t ModifiedListBucketIndex : 4;
    uint8_t AnchorLargePageSize : 2;
    // anonymous tag for u4
} MMPFN, *PMMPFN;// Windows版本为win10 19044.1766
```

​	内存管理器创建并维护了一种名为页表(page table)的数据结构，CPU会借助页表将虚拟地址转换为物理地址。虚拟地址空间中的每个页都会关联至一种名为页表项(Page table Entry，PTE)的系统空间结构(_MMPTE)，PTE 包含了虚拟地址所映射到的物理地址信息。

```c++
union _MMPTE {
    uint64_t Long;
    uint64_t VolatileLong;

    struct MMPTE_HARDWARE {
        uint64_t Valid : 1;
        uint64_t Dirty1 : 1;
        uint64_t Owner : 1;
        uint64_t WriteThrough : 1;
        uint64_t CacheDisable : 1;
        uint64_t Accessed : 1;
        uint64_t Dirty : 1;
        uint64_t LargePage : 1;
        uint64_t Global : 1;
        uint64_t CopyOnWrite : 1;
        uint64_t Unused : 1;
        uint64_t Write : 1;
        uint64_t PageFrameNumber : 36;
        uint64_t ReservedForHardware : 4;
        uint64_t ReservedForSoftware : 4;
        uint64_t WsleAge : 4;
        uint64_t WsleProtection : 3;
        uint64_t NoExecute : 1;
    } Hard;
};// Windows版本为win10 19044.1766
```

> 注意 就算内核模式代码(如设备驱动程序)也无法直接引用物理内存地址，但可首先创建虚拟地址并映射至物理内存，借此间接引用。详细信息请参阅 WDK 文档中有关内存描述列表(MDL)支持例程的介绍

​	到转换系统的输入包含一个32 位虚拟地址(这也是32位体系结构的可寻址范围)以及一些与内存有关的结构 [页表、页目录、一个页目录指针表(Page Directory Pointer Table,PDPT)和转换旁视缓冲区] 输出内容则是一个指向物理内存的 36位物理地址，这也是数据的真正所在位置。“36”这个数字源自页表的结构和组织方式，这是处理器决定的。如果映射的是小页面，来自虚拟地址最低位的12位会直接复制到转换后的物理地址中。12位恰恰等同于4KB，也就是小页面的大小。

​	待转换的32位虚拟地址从逻辑上可划分为4部分。最低的12位将“照原样”用于选择页面中的特定字节。转换过程首先从每颗处理器上的一个PDPT开始它会始终驻留在物理内存中。(否则系统将找不到它)它的物理地址存储在每颗处理器的KPROCESS结构中。对于当前执行的进程，一个特殊的x86寄存器CR3存储了该进程的这个值(正是借助这个值，线程才得以访问虚拟地址)。这意味着当某颗CPU进行上下文切换时，如果新老线程运行在不同进程中，则必须向CR3 寄存器载入源自KROCESS结构的新进程页目录指针地址。PDPT 必须与 32字节的边界对齐，同时必须位于物理内存的前4GB中(因为x86体系结构的CR3依然是32位的寄存器)。

<img src=".\Windows%20Address%20translation.assets\image-20230328195509541.png" alt="image-20230328195509541"  />

按照上图所示的布局，将虚拟地址转换为物理地址的顺序如下。

(1)	虚拟地址中最重要的两个位(第30和31位)提供了到PDPT的索引。该表包含4项，所选项[页目录指针项(Page Directory Pointer Entry，PDPE)]将指页目录的物理地址。

(2)	页目录中包含 512个项，虚拟地址的第21~29 位(共9位)将选择其中一个项所选页目录项(Page Directory Entry，PDE)将指向页表的物理地址。

(3)	页表也包含 512个项，虚拟地址的第 12~28 位(共9位)也将选择其中一个项所选页表项 (PTE) 将指向页面起始位置的物理地址。

(4)	虚拟地址偏移量(较低的 12位)被添加至PTE 指向的地址，进而为调用方提供所请求的最终物理地址。

​	上述各种表中的每一项也叫作页面帧编号(Page Frame Number，PFN)，因为它们指向的是与页面对齐的地址。每个项64 位宽，因此页目录或页表的大小不会超过一个4KB的页。但严格来说，要描述一个64GB 的地址范围，只有其中24位是必要的(外加代表地址范围移量的12位，共36位)。

​	但这些额外的位数中有一位对整个机制而言尤为重要一一验证位。借助这一位，我们可以知道 PFN 数据是否确实有效，进而可以决定 CPU 是否需要执行上述过程。但是，该位被清空，则代表出现了页面错误。CPU 将抛出一个异常，并等待操作系统通过某种有意义的方式处理这个页面错误。举例来说，如果有问题的页面之前曾被写入磁盘，那么存管理器需要将其重新读入物理内存中的可用页面，从而解决PTE问题，并让CPU重试。

​	由于Windows为每个进程提供了私有地址空间，每个进程都有用于映射自己私有地址空间所需的PDPT、页目录和页表。然而，描述系统空间的页目录和页表是所有进程共享的(会话空间仅在一个会话包含的进程之间共享)。为避免用多个页表描述同一块虚拟内存，描述系统空间的页目录项在初始化后会指向创建进程时现有的系统页表。如果进程是某会话的一部分，会话空间页表会将会话空间页目录项指向现有会话空间表，借此实现共享。

#### 页表和页表项

​	页目录和页表的布局基本相同。我们可以使用内核模式调试器的!pte 命令查看PTE，有效PTE 包含两个主要字段:包含数据的物理页面(即页面在内存中的物理地址)的PFN描述页面状态和保护属性的某些标志，如下图：

![image-20230328200624956](./Windows%20Address%20translation.assets/image-20230328200624956.png)

无论PTE是否有效，上图所示的“软件”和“保留”位都会被CPU中的内存管理单元(MMU)所忽略。这些位的存储和解读都由内存管理器负责。下表简要描述了有效PTE 中，由硬件定义的位。

| 位的名称       | 含义                                                         |
| -------------- | ------------------------------------------------------------ |
| Accessed       | 该页面已被访问过                                             |
| Cache disabled | 为该页面禁用CPU缓存                                          |
| Copy-on-write  | 该页面使用了写入时复制                                       |
| Dirty          | 该页面已被写入过                                             |
| Global         | 该转换适用于所有进程，例如，转换缓冲区的刷新操作不会影响这个PTE |
| Large page     | 代表该PDE映射至一个 2MB 页面                                 |
| No execute     | 代表该页面中的代码不可执行(只能用于存储数据)                 |
| Owner          | 代表用户模式代码是否可访问该页面，或该页面是否仅限内核模式访问 |
| Prototype      | 该PTE属于原型PTE，可用作模板来描述与节对象关联的共享内存     |
| Valid          | 代表该转换是否映射至物理内存中的页面                         |
| Write through  | 可将页面标记为写入直达，但前提是处理器支持页面属性表和并写入(writecombined)。通常该标志可用于映射视频帧缓冲区内存 |
| Write          | 可以告知MMU，该页面是否可以写入                              |

​	在x86系统中，硬件PTE包含两个能被MMU修改的位:Dirty位和Accessed位。如果页面被读取或写入，MMU便会设置Accessed 位(如果尚未设置的话)。如果对页面进行了写入操作，MMU会设置 Dirty 位。操作系统负责在恰当的时间清除这些位，但MMU绝对不会进行清除。

​	x86MMU使用一个Write位为页面提供保护。如果这个位被清除，页面将成为只读的。如果设置了该位，页面可以读取或写入。如果线程试图向 Write 位已经被清除的页面写入数据，将发生内存管理异常。此外内存管理器的访问错误处理程序必须决定是要允许线程写入页面(例如，该页面是否真的被标记为写入时复制)，还是产生访问冲突。

#### 页表项中的硬件和软件 Write 位

​	由软件实现的一个额外Write位可强制将Dirty位的更新操作与Windows内存管理数据的更新保持同步。此时一种简单的实现是:内存管理器为所有可写页面设置硬件Write位(位1)，随后对此类页面的写操作会导致MMU设置PTE中的Dirty位。接下来，这个 Dirty位即可告诉内存管理器:必须先将这个物理页面中的内容写入后备存储，随后才能将该物理页面用于其他用途。

​	在实践中，对于多处理器系统，这可能导致竞争条件，并且解决此条件的代价非常大多颗处理器的MMU将可以随时为设置了硬件Write位的任何PTE设置Dirty位为了反映PTE中Dirty位的状态，内存管理器必须随时更新进程的工作集列表。内存管理器会使用推锁来同步对工作集列表的访问。但是在多处理器系统中，即使一颗处理器可能持有了这个锁，但Dirty 位依然可能被其他处理器的MMU更改。这将增大错过Dirty位更新的概率。

​	为了避免这种问题，Windows内存管理器在初始化只读和可写页面时，会将它们PTE的硬件 Write 位(位1)设置为0，并将页面真正的可写与否状态记录在软件 Write位(位11)中。首次写入这样的页面时，处理器将产生内存管理异常，因为硬件 Write 位已被清除了，就好像产生了一个真正的只读页面。不过此时内存管理器其实知道页面是可以写入的(借助软件 Write位获知)，因此会获取工作集推锁、在PTE中设置 Dirty 位和硬件 Write位、更新工作集列表代表该页面已经被修改、释放工作集推锁，然后解除该异常。随后即可照常进行硬件写操作，但 Dirty 位的存在使得这一切只能在持有工作集列表推锁的情况下实现。

​	随后写入该页面时将不再出现异常，因为已经设置了硬件 Write 位。MMU会用冗余方式设置 Dirty 位，不过这并不会造成任何问题，因为页面的“写入过”状态已经被记到工作集列表中了。强制对页面的首次写操作必须经历上述异常处理过程，这可能显得代价太大，然而对于每个可写入的页面，只要页面本身始终维持有效，这种操作只需要进行一次。此外，首次访问几乎所有页面都需要经历内存管理异常处理，因为页面通常都会初始化为无效状态(PTE位0被清除)。如果对页面的首次访问同时也是对该页面的首次访问，那么在处理首次访问页面错误过程中，还会进行上述的Dirty 位处理过程，这样看起来额外的开销就不那么大了。最后，在单处理器和多处理器系统中，这种实现还可允许在不需要对被刷新的页面持有锁的情况下刷新地址转换旁视缓冲区。

### 地址转换旁视缓冲区

每个硬件地址转换都需要进行如下 3 次查找

(1)一次在 PDPT 中找到正确的项。

(2)一次在页目录中找到正确的项(该项提供了页表的位置).

(3)一次在页表中找到正确的项。

​	由于对每个虚拟地址的引用都必须进行 3 次额外的内存查找，这会将所需内存带宽增大4 倍进而影响到性能，因此所有 CPU 都会缓存地址转换结果，避免在重复访问相同地址时重复转换。这种缓存是一种由联合存储器 (associative memory) 组成的数组，名为地址转换旁视缓冲区(Translation Lookaside Buffer，TLB)。联合存储器是一种向量，其中包含的单元可以并发读取并与目标值进行对比。在 TLB 中，向量包含了大部分常用页面的虚拟到物理页面映射，如下图所示，还包含了应用于每个页面的页面保护、大小、属性等信息。TLB 中的每个项可视作一种缓存项，使用标签保存了虚拟地址的一部分，而这些项的数据部分保存了物理页面号、保护字段和有效位，通常还会包含一个 Dirty 位，用于代表该缓存PTE所对应的页面条件。如果PTE的全局位已设置(Windows会为对所有进程可见的系统空间页进行此设置)，则TLB 项在进程上下文切换时就不会被视作无效。

![image-20230328204012032](./Windows%20Address%20translation.assets/image-20230328204012032.png)

### x64 虚拟地址转换

​	x64的虚拟地址转换与x86 类似，但额外增加了第四个级别。每个进程有一个可扩展的顶级页目录，名为4级页映射表 (page map level 4 table)，其中包含512个第三级结构(叫作页目录指针，page directory pointer)的物理位置信息。页面父目录类似于x86 PAE PDPT，但页面父目录共有 512个，而x86的PAE PDPT只有一个，每个页面父目录都是一个完整的页，其中包含了512个(而非仅仅4个)项。与PDPT类似，页面父目录的项包含了二级页目录的物理位置，而每个二级页目录也包含512个项，指向每个页表的位置最后，每个页表也包含 512 个页表项，每个页表项指向内存中页面的物理位置。本段前文所有“物理位置”都以PFN的形式存储在这些结构中。

​	X64 体系结构的当前实现限制了虚拟地址为48位。这48 位虚拟地址的组成部分,以及地址转换过程中不同组成部分之间的关系如图 5-36所示，x64 硬件PTE的格式如图5-37所示。

![image-20230328204832509](./Windows%20Address%20translation.assets/image-20230328204832509.png)

![image-20230328204849087](./Windows%20Address%20translation.assets/image-20230328204849087.png)

### ARM 虚拟地址转换

ARM 32位处理器的虚拟地址转换使用了一种包含 1024 项的单个页目录，每个项的大小为32位。ARM虚拟地址转换结构如图 5-38 所示。

![image-20230328205014306](./Windows%20Address%20translation.assets/image-20230328205014306.png)

​	每个进程有一个页目录，其物理地址存储在 TTBR 寄存器中(类似于x86/x64的CR3寄存器)。虚拟地址中的10个最高位选择的PDE可能指向1024个页表中的一个表。虚拟地址的最后10位将选择一个特定的PTE。每个有效的PTE可指向物理内存中页面的起始位置，并由虚拟地址中随后的12 位提供偏移量(与x86和x64 的情况类似)。图5-38示的结构还暗示了可寻址的物理内存为4GB，因为每个PTE(32位)都小于x86/x64(64位)，并且实际上只有 20位会用于 PFN。ARM 处理器也支持 PAE 模式(与x86类似),但 Windows 并未使用该功能。未来的 Windows 版本也许会支持ARM64 位体系结构，进而缓解物理地址方面的局限，并大幅增加进程和系统的虚拟地址空间范围。

​	奇怪的是，有效PTE、PDE以及大页PDE的布局并不相同。图5-39展示了目前Windows所用的ARM v7的有效PTE布局。详细信息请参阅ARM官方文档。

![image-20230328205307389](./Windows%20Address%20translation.assets/image-20230328205307389.png)

