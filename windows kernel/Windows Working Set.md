# 工作集

驻留在物理内存中的虚拟页面子集也可以叫作工作集 (working set)。工作集的类型有如下3 种。
(1) **进程工作集**。包含被一个进程中的线程所引用的页面。
(2) **系统工作集**。包含可换页系统代码 (如 Ntoskrnl.exe 和驱动程序)、换页池以及系统缓存驻留在物理内存中的子集。
(3) **会话工作集**。每个会话都有一个工作集，其中包含了下列内容驻留在物理内存中的子集:由Windows子系统(Win32k.sys)内核模式部分所分配的与该会话有关的内核模式数据结构、会话换页池、会话映射视图以及其他会话空间设备驱动程序。

---

### 按需换页

​	Windows 内存管理器使用按需换页算法将页面以簇的形式载入内存。当线程收到页面错误后，内存管理器会将出错页面，外加该页面的少量前序或后续页面一起载入内存。这种策略意在将线程导致的换页 I/O数量降至最低。因为程序(尤其是大型程序)在任何特定时间内总是倾向于在自己地址空间的这一小块区域内执行，所以成簇加载虚拟页面可以减少磁盘读取操作数量。对于引用映像中的数据页面导致的页面错误，簇的大小为 3个页面；对于其他所有页面错误，簇的大小为7个页面。

---

### 逻辑预取器和 ReadyBoot

​	在典型的系统引导或应用程序启动过程中，页面错误顺序为:从一个文件的一部分中读取一些页面，随后也许要从同一个文件较远的部分、从不同的文件、甚至可能从目录读取页面，然后再次从第一个文件中读取其他页面。这种来回跳转大幅降低了每次访问的速度。其实分析发现，磁盘寻道时间已经成为降低系统引导和应用程序启动速度的首要因素。通过一次性预取大批页面的方式，即可获得更合理的访问顺序并避免过多的来回跳转，进而改善系统和应用程序启动的整体速度。能够提前得知需要哪些页面，是因为系统引导或应用程序启动过程中访问的数据有极高的相关性。

​	预取器会试图监视系统引导和应用程序启动过程中访问的数据和代码,并在下一次系统引导或应用程序启动的开始时刻使用这些信息读取代码和数据,借此加快系统引导和应用程序启动的速度。在激活预取器后，内存管理器会将页面错误(包括硬错误，即所需数据必须从磁盘读取，以及软错误，即所需数据已经位于物理内存中，只不过需要添加至进程的工作集)告知预取器代码。预取器会监视应用程序启动过程的前 10s。对于系统的引导，预取器默认会从系统启动开始跟踪，直到用户外壳(通常为Explorer)启动后的30s,或者如果失败的话，则会跟踪到 Windows 服务初始化之后的 60s，或总共跟踪 120s，这取决于哪个条件首先实现。

​	内核中收集的跟踪记录会记录发生在下列内容上的页面错误:NTFS 主文件表(Master File Table，MFT) 元数据文件(如果应用程序访问了NTFS 卷上的文件或目录)、被引用的文件以及被引用的目录。借助收集到的跟踪记录，内核预取器代码会等待来自 Superfetch服务(%SystemRoot%\System32\Sysmain.dll，该服务运行在一个Svchost 实例中)的预取器组件请求。Superfetch 服务负责内核中的逻辑预取组件以及稍后提到的SuperFetch组件。预取器发送KernelObjectsPrefetchTracesReady 事件给 Superfetch 服务，随后 Superfetch服务即可查询跟踪记录数据。

>注意  若要启用或禁用系统引导或应用程序启动时的预取，可修改名为 EnablePrefetcher的 DWORD注册表值，该值位于注册表 HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters键下。设置为0可全面禁用预取，设置为1可仅启用应用程序启动预取，设置为 2 可仅启用系统引导预取，设置为3 可同时为系统引导和应用程序启动启用预取。

​	Superfetch 服务(承载了逻辑预取器，不过预取器是独立于 SuperFetch 功能的一个单独组件)执行内部的 NtQuerySystemInformation 系统调用，请求跟踪记录数据。逻辑预取器在处理跟踪记录数据后，将其与之前收集的数据结合在一起，并写入位于%SystemRoot%\Prefetch 目录的文件中。

​	系统的引导则使用了一种名为 ReadyBoot 的不同机制。ReadyBoot 会试图创建更大更高效的I/0读取，并将读到的数据保存在物理内存中，借此优化I/O操作。当系统组件需要这些数据时，即可通过物理内存直接获取。这一特性对机械硬盘尤为实用，SSD 固态硬盘也能从中获益。当系统引导后，需要预取的文件信息会存储在图%SystemRoot%\Prefetch目录下的ReadyBoot子目录中。一旦引导完成，物理内存中缓存的数据会被删除。对于速度非常快的SSD，ReadyBoot 默认会被关闭，因为该机制所能起到的作用极为有限甚至毫无效果。

​	当系统引导或应用程序启动时，预取器会被调用进而开始预取。预取器会检查Prefetch目录，并确定对于当前的预取场景是否存在现有的跟踪文件。如果有，预取器会调用NTFS来预取MFT元数据文件引用，读取被引用的每个目录中的内容，最后打开每个被引用的文件。随后预取器会调用内存管理器函数MmPrefetchPages 以读取跟踪记录中指定、但前不存在于内存中的所有数据和代码。内存管理器会以异步方式发起所有读取操作，随后等待操作完成并让应用程序的启动过程继续。

​	为了进一步缩短磁盘寻道时间，每3天左右，Superfetch 服务会在系统空闲过程中按照引导或应用程序启动的顺序将访问过的文件和目录整理出一个列表，并将其保存在%SystemRoot%\Prefetch\ Layout.ini文件。该列表还包含Superfetch 服务追踪到的频繁访问的文件。

​	随后将启动系统碎片整理程序，并通过命令行选项告诉碎片整理程序按照该文件的内容进行碎片整理，而非进行全面的碎片整理。碎片整理程序会在每个卷上寻找一个足够大的连续区域来保存上述文件中列出的、位于该卷上的所有文件和目录，随后将这些内容整体移入该区域，使其能够连续地存储在一起。借此，后续预取操作即可更高效，因为所有需要读取的数据都在物理上按照读取顺序存放在了一起由于需要为预取机制整理碎片的文件通常只有数百个，因此这种碎片整理过程本身也要比整卷碎片整理快很多。

---

### 放置策略

​	当线程收到页面错误时，内存管理器必须决定要将虚拟页面放在物理内存的什么位置。系统会通过名为放置策略(Placement policy)的一系列规则来确定最佳位置。Windows 在选择页面帧时,为了将不必要的缓存抖动 (thrashing) 降至最低，会充分考虑CPU 内存缓存的大小。

> 放置策略（Placement Policy）是内存管理器用来确定将虚拟页面放置在物理内存的哪个位置的一系列规则。内存管理器需要在为一个虚拟页面分配物理内存时，确保选择一个合适的位置以保持高性能和内存利用率。以下是一些常见的放置策略：
>
> 1. 最佳适应（Best Fit）：在这种策略下，内存管理器会选择一个能够最精确地容纳请求大小的空闲内存块。这有助于减少内存碎片，但可能会导致搜索可用空间变得更加复杂和耗时。
> 2. 首次适应（First Fit）：内存管理器会选择第一个足够大的空闲内存块来容纳请求。这种策略的搜索过程相对较快，但可能会导致更多的内存碎片。
> 3. 最差适应（Worst Fit）：内存管理器会选择最大的空闲内存块来容纳请求。这种策略的目的是让较大的内存块保持连续，以便将来处理大型请求。然而，这可能会导致大量的内存碎片。
> 4. 下一个适应（Next Fit）：这是首次适应策略的一个变种。在这种策略下，内存管理器会从上次分配的地方开始搜索，而不是从内存的起始位置开始。这样可以加快搜索速度，但同样可能导致内存碎片。

​	如果出现页面错误时物理内存已满，Windows 会使用一条置换策略 (replacement policy) 来决定必须将哪些虚拟页面从内存中移出，以便为新页面留出位置。常见的置换策略

1. 最佳置换（Optimal Replacement）：这种策略会选择在未来最长时间内不会被访问的页面进行替换。虽然这种策略理论上是最佳的，但由于它需要知道未来的访问模式，因此在实际应用中是不可行的。
2. 最近最少使用（Least Recently Used, LRU）：这种策略选择最长时间未被访问的页面进行替换。LRU策略的一个主要缺点是实现成本较高，因为需要在每次访问时更新页面的访问时间戳。
3. 先进先出（First-In, First-Out, FIFO）：这种策略选择最早加载到内存中的页面进行替换。尽管实现简单，但这种策略可能导致性能较差，因为最早加载的页面可能仍然是活跃的。
4. 时钟置换（Clock Replacement）：这种策略是LRU策略的一种近似实现。时钟置换使用一个循环队列和一个指针来模拟页面访问的顺序。每个页面都有一个访问位，当页面被访问时，该位被设置为1。当需要替换页面时，指针从当前位置开始顺时针扫描，遇到访问位为0的页面则将其替换，否则将访问位清零并继续搜索。
5. 随机置换（Random Replacement）：这种策略通过随机选择一个页面进行替换。尽管实现简单且不依赖于访问模式，但可能导致性能较差。

​	置换策略还可以进一步分为全局的或局部的。全局置换策略可以用任何页面帧满足页面错误，无论该页面帧是否被其他进程所拥有。例如，使用 FIFO 算法的全局置换策略可以找到在内存中存在时间最久的页面，将其移除以满足页面错误的需求。局部置换策略则只能在产生了该页面错误的进程所拥有的页面中寻找并移除最老的页面。

---

### 工作集管理

​	每个进程启动时都有一个默认的工作集最小值 (50 个页面)和工作集最大值 (345个页面)。虽然效果有限，但我们可以使用Windows的SetProcessWorkingSetSize 函数更改作集的这些限制，前提是具备增加调度优先级的特权(SeIncreaseBasePriorityPrivilege)。然而除非为进程配置使用硬性工作集限制，否则这些限制会被忽略。也就是说，如果换页频繁并且有足够的内存，内存管理器会允许进程工作集增长到超出最大值的限制。(反之，如果未进行换页操作，并且系统中物理内存非常紧缺，内存管理器会将进程收缩至低于工作集最小值的限制。)我们可以使用 SetProcessWorkingSetSizeEx 函数并配合 QUOTA_LIMITS_HARDWS_MAX_ENABLE 标志为工作集设置硬性限制。

​	在32位系统中，工作集的最大值不能超过系统初始化时在系统范围内计算而来的最大值，该数值存储在内核变量MiMaximumWorkingSet中。在x64系统中，由于虚拟地址空间足够巨大，物理内存远远不会超过上限。工作集的最大值上限见下表

| Windows版本                                 | 工作集最大值               |
| ------------------------------------------- | -------------------------- |
| x86、ARM                                    | 2GB-64KB(0X7FFF0000)       |
| 使用increaseuserva选项引导的x86版本 Windows | 2GB-64KB+ 用户虚拟地址增量 |
| x64 (Windows 8、Server 2012)                | 8192GB (8TB)               |
| x64 (Windows 8.1、10、Server 2012 R2、2016) | 128TB                      |

​	如果发生页面错误，就会检查该进程的工作集限制以及系统中空闲内存的数量。如果条件允许，内存管理器会允许进程增大至自己工作集的最大值(如果进程工作集无硬性限制并且有足够的空闲页面可供使用，还可增大至超出最大值)。但是，如果内存紧张，Windows会在发生页面错误后置换工作集中的页面，而非添加新页面。

​	工作集管理器负责监控系统内存使用情况并进行调整。它首先检查可用内存并确定是否需要对工作集进行修剪。若有足够内存，工作集管理器将计算可以从工作集中移除的页面数量。在需要修剪的情况下，它会优先检查超过最小值设置的工作集，并根据进程特点以优化顺序进行检查。

​	工作集管理器会确定可以从某个进程的工作集中移除的页面，以便供其他进程使用。如果移除后空闲内存仍不足，将继续移除页面，直到系统空闲页面达到最小值。在此过程中，工作集管理器会尝试移除最近未被访问过的页面，通过检查硬件PTE的Accessed位来判断页面的访问情况。这种扫描会持续进行，直至移除所需数量的页面或回到起点为止。下一次修剪工作集时，扫描将从上次停止的位置继续。

---

### 平衡集管理器和交换器

​	工作集的扩展和修剪是在一个名为平集管理器(KeBalanceSetManager 函数)的系统线程上下文中进行的。平衡集管理器会在系统初始化过程中创建。虽然从技术上来说，平衡集理器也是内核的一部分，但它需要调用内存管理器的工作集管理器(MmWorkingSetManager执行工作集分析和调整工作。

​	平衡集管理器会等待两个不同的事件对象：一个事件会在某个被设置为每秒触发一次的周期性计时器过期后被设置为有信号状态；另一个是工作集管理器的内部事件，当不同点上的存管理器判断需要对工作集进行调整时，会将该事件设置为有信号状态。举例来说，如果系正在很频繁地遇到页面错误，或空闲列表太小，内存管理器会唤醒平衡集管理器，进而由后者调用工作集管理器开始修剪工作集。当内存足够多时，工作集管理器会允许产生页面错误的进程将出错页面换入内存，借此逐渐增大其工作集的大小。但工作集只会根据需求增长。

​	当平衡集管理器由于1秒计时器到期而被唤醒时，将执行下列操作。

1. 如果系统支持虚拟安全模式 (Virtual Secure Mode，VSM)(Windows 10和Windows Server 2016的新功能)将调用安全内核进行周期性的清理工作(VslSecureKernelPeriodicTick)。
2. 调用一个例程来调整 IRP 额度以优化 IRP 完成时将会用到的每颗处理器旁视列表用量(IoAdjustIrpCredits)。这样当某颗处理器面临繁重的I/O负载时将能获得更佳的可缩放性。
3. 检查旁视列表并调整其深度(如果必要的话)以改善访问速度，并减少内存池用量和降低内存池碎片化程度(ExAdjustLookasideDepth)。
4. 通过调用以调整 Windows 事件追踪(ETW)缓冲区池大小，以便更高效地使用ETW内存缓冲区(EtwAdjustTraceBuffers)
5. 调用内存管理器的工作集管理器。工作集管理器有自己的内部计数器，借此调节何时修剪并确定修剪程度。
6. 为作业强制应用执行时间 (PsEnforceExecutionLimits)
7. 如果平衡集管理器由于1秒计时器到期而被唤醒，并且每当这样的唤醒被累积到第八次时，便会向一个事件发送信号进而唤醒另一个名为交换器 (swapper)的系统线程(KeSwapProcessOrStack)。交换器线程的任务是回收长时间未执行线程的内核栈所占用的物理内存。

> 交换器线程运行在较高的优先级（优先级23）下，寻找已经处于等待状态15秒的用户模式线程。找到这样的线程后，交换器会将该线程的内核栈改为转换状态（将其页面移入已修改或待命列表），从而回收其物理内存。这样做的原因是，如果一个线程已经等待了足够长的时间，那么它可能会继续等待更长时间。
>
> 当进程中最后一个线程的内核栈从内存中移除后，该进程被标记为彻底换出。这也解释了为什么空闲足够久的进程（如Wininit或Winlogon）的工作集大小可能为零。

---

### 系统工作集

​	正如进程可以通过进程工作集管理进程地址空间中可换页的部分，系统地址空间中可换页的代码和数据也可以通过如下3个全局工作集加以管理，这3个全局工作集统称为系统工作集

1. 系统缓存工作集。包含驻留在系统缓存中的页面。
2. 换页池工作集。包含驻留在换页池中的页面
3. 系统PTE 工作集。包含来自下列对象的可换页代码与数据:已加载动程序和内核映像，已映射至系统空间的内存节页面。

下表列出了这3个系统工作集的存储位置

| 系统工作集类型 | 存储位置(Windows 8.x、Windows Server 2012/2012R2) | 存储位置(Windows 10、Windows Server 2016) |
| -------------- | ------------------------------------------------- | ----------------------------------------- |
| 系统缓存       | MmSystemCacheWs                                   | MiState.SystemVa.SystemWs[0]              |
| 换页池         | MmPagedPoolWs                                     | MiState.SystemVa.SystemWs[2]              |
| 系统PTE        | MmSystemPteWs                                     | MiState.SystemVa.SystemWs[1]              |

​	我们可以使用下表列出的性能计数器或系统变量查看这些工作集及其组成部分的大小。

| 性能计数器(以字节数为单位)                                  | 系统变量(以页面数为单位)                                     | 描述                                   |
| ----------------------------------------------------------- | ------------------------------------------------------------ | -------------------------------------- |
| Memory: Cache Bytes<br> Memory: System Cache Resident Bytes | WorkingSetSize 成员                                          | 文件系统缓存消耗的物理内存数           |
| Memory: Cache Bytes Peak                                    | PeakWorkingSetSize 成员(Windows 10 和 Windows Server 2016)<br>Peak 成员(Windows 8.x和 Windows Server 2012/2012 R2) | 系统工作集的峰值大小                   |
| Memory: System Driver Resident Bytes                        | SystemPageCounts.SystemDriverPage (全局，Windows 10 和 Windows Server 2016) <br>MmSystemDriverPage(全局，Windows 8.x和 Windows Server 2012/2012 R2) | 可换页设备驱动程序代码消耗的物理内存数 |
| Memory: Pool Paged Resident Bytes                           | WorkingSetSize成员                                           | 换页池消耗的物理内存数                 |

​	我们还可以通过Memory: Cache Faults/Sec 这个性能计数器查看系统缓存工作集的换页活动。该计数器代表了系统缓存工作集中(软性和硬性)页面错误的数量。该计数器的值位于系统缓存工作集结构的PageFaultCount成员中。

---

### 内存通知事件

​	当物理内存、换页池、非换页池以及提交用量很少或很多时，Windows 为用户模式进程和内核模式驱动程序提供了一种方法，向它们通知这些情况。这些信息可用于在必要时确定内存用量。

​	用户模式进程只有在内存少或多的时收到通知。应用程序可以调用CreateMemoryResourceNotification 函数来指定自己期望接收到内存多或内存少的通知，借此获得的句柄可提供给任何等待函数。当内存少(或多)时，等待结束进而通知线程所等待的条件已经满足。或者可以随时使用QueryMemoryResourceNotification 查询系统内存状况，而无须阻塞调用方线程。

​	另一方面，驱动程序可以使用内存管理器在\KernelObjects 对象管理器目录下建立的特定事件名称来接收通知。这是因为这种通知是由内存管理器将自己定义的全局命名事件对象(见下表)设置为有信号状态而实现的。在检测到特定内存状况后，相应事件被设置为有信号状态，进而唤醒等待线程。

| 事件名称                  | 描述                                                         |
| ------------------------- | ------------------------------------------------------------ |
| HighCommitCondition       | 如果提交用量接近最大提交限制，即内存用量非常大，物理内存或页面文件中可用空间极为有限，且操作系统无法增加页面文件的大小，将设置该事件 |
| HighMemoryCondition       | 当空闲物理内存数量超过预设值时将设置该事件                   |
| HighNonPagedPoolCondition | 当非换页池用量超过预设值时将设置该事件                       |
| HighPagedPoolCondition    | 当换页池用量超过预设值时将设置该事件                         |
| LowCommitCondition        | 当提交用量相对当前提交限制较低，即内存用量低，且物理内存或页面文件中存在大量可用空间时，将设置该事件 |
| LowMemoryCondition        | 当物理内存空闲数量低于预设值时将设置该事件                   |
| LowNonPagedPoolCondition  | 当非换页池空闲数量低于预设值时将设置该事件                   |
| LowPagedPoolCondition     | 当换页池空闲数量低于预设值时将设置该事件                     |
| MaximumCommitCondition    | 如果提交用量接近最大提交限制，即内存用量非常大，物理内存或页面文件中可用空间极为有限，且操作系统无法增加页面文件的大小或数量时，将设置该事件 |
| MemoryErrors              | 代表检测到的坏页面(未成功清零的零页面)数量                   |

> 注意 我们可以在注册表HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management键下添加 LowMemoryThreshold 或 HighMemoryThreshold 这两个 DWORD注册表值，借此更改大内存和小内存的值。此处需要以MB为单位指定大小阈值的数值。也可以配置系统在检测到坏页面时直接崩溃，而不再发送内存错误事件，为此需要将上述注册表键下PageValidationAction 这个DWORD注册表值的数值设置为“1”
